{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to eraXplor","text":"<p>AWS Cost Export Tool for automated cost reporting and analysis.</p> <p>eraXplor is an automated AWS cost reporting tool designed for assest DevOps and FinOps teams fetching and sorting AWS Cost Explorer. it extracts detailed cost data by calling AWS Cost Explorer API directly and Transform result as a CSV. <code>eraXplor</code> gives you the ability to sort the cost by Account or even By Service, as well as format and separate the result Monthly.</p> <p><code>eraXplor</code> is still under enhancement and this is an 'Initial Model'</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\u2705 Account-Level Cost Breakdown: Monthly unblended costs per linked account.</li> <li>\u2705 Service-Level Cost Breakdown: Monthly unblended costs per Services.</li> <li>\u2705 Flexible Date Ranges: Custom start/end dates with validation.</li> <li>\u2705 Multi-Profile Support: Works with all configured AWS profiles.</li> <li>\u2705 CSV Export: Ready-to-analyze reports in CSV format.</li> <li>\u2705 Cross-platform CLI Interface: Simple terminal-based workflow, and Cross OS plateform.</li> <li>\u2705 Documentation Ready: Well explained documentations assest you kick start rapidly.</li> <li>\u2705 Open-Source: the tool is open-source under Apache02 and GNU licenses, which enables your to enhance it for your purpose.</li> </ul>"},{"location":"#why-eraxplor","title":"Why eraXplor?","text":"<pre><code>graph LR\n    A[AWS Console] --&gt;|Complex UI| B[Manual Export]\n    B --&gt; C[Spreadsheet Manipulation]\n    D[eraXplor] --&gt;|Automated| E[Standardized Reports]\n    style D fill:#4CAF50,stroke:#388E3C\n</code></pre>"},{"location":"#table-of-contents","title":"Table Of Contents","text":"<p>Quickly find what you're looking for depending on your use case by looking at the different pages.</p> <ol> <li>Tutorials</li> <li>How-To Guides</li> <li>Reference</li> <li>Explanation</li> </ol>"},{"location":"#about-the-author","title":"About the Author","text":"Show/Hide Author Details <p>Mohamed eraki Cloud &amp; DevOps Engineer</p> <p>Cloud and DevOps engineer with a total of 5 years experience in technologies. With 2 years of experience in Cloud and DevOps, specializing in implementing and optimizing cloud-based 'Fin-Tech' solutions, and 3 years of experience focused on on-prem 'Fin-Tech' solutions.</p> <p> </p>"},{"location":"#project-philosophy","title":"Project Philosophy","text":"<p>\"I built eraXplor to solve real-world cloud cost visibility challenges \u2014 the same pain points I encounter daily in enterprise environments. This tool embodies my belief that financial accountability should be accessible to every technical team.\"</p>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<p>Special thanks to the open source community for:</p> <ul> <li>RealPython</li> <li>boto3 - AWS SDK for Python</li> <li>mkdocs-material - Documentation framework</li> </ul>"},{"location":"explanation/","title":"Explanation","text":""},{"location":"explanation/#understanding-aws-cost-visibility-challenges","title":"Understanding AWS Cost Visibility Challenges","text":"<p>In big Architectural designs, AWS Cloud Architects tend to segregate resources via multi AWS Accounts environment/Landing Zone environment.</p> <p>Manual Cost visibility, comparison, and Reconciliation, versus these multi accounts, become overwhelming as we go. based on how many accounts you have and months you wanna compare.</p> <p>Even in a tiny Architectural design, Manual Comparing the current cost of all consumied Services agianest the months before, become overwheming, based on the how many services you consiume and months you intend to compare.</p>"},{"location":"explanation/#how-eraxplor-addresses-these-challenges","title":"How eraXplor Addresses These Challenges","text":"<p><code>eraXplor</code> is a CLI tool deliver an automatic way to aggregate cost data based on user inputs and export these data into CSV format.</p> <ul> <li>Aggregate cost data per AWS Accounts.</li> <li>Aggregate cost data per AWS Services.</li> <li>Export data in reports, CVS format. </li> <li>Suport AWS profile Credintials.</li> <li>Cross-platform CLI interface.</li> </ul>"},{"location":"explanation/#key-features","title":"Key Features","text":"<ul> <li>\u2705 Account-Level Cost Breakdown: Monthly unblended costs per linked account.</li> <li>\u2705 Service-Level Cost Breakdown: Monthly unblended costs per Services.</li> <li>\u2705 Flexible Date Ranges: Custom start/end dates with validation.</li> <li>\u2705 Multi-Profile Support: Works with all configured AWS profiles.</li> <li>\u2705 CSV Export: Ready-to-analyze reports in CSV format.</li> <li>\u2705 Cross-platform CLI Interface: Simple terminal-based workflow, and Cross OS plateform.</li> <li>\u2705 Documentation Ready: Well explained documentations assest you kick start rapidly.</li> <li>\u2705 Open-Source: the tool is open-source under Apache02 and GNU licenses, which enables your to enhance it for your purpose.</li> </ul>"},{"location":"explanation/#why-eraxplor","title":"Why eraXplor?","text":"<pre><code>graph LR\n    A[AWS Console] --&gt;|Complex UI| B[Manual Export]\n    B --&gt; C[Spreadsheet Manipulation]\n    D[eraXplor] --&gt;|Automated| E[Standardized Reports]\n    style D fill:#4CAF50,stroke:#388E3C\n</code></pre>"},{"location":"how-to-guides/","title":"How-To Guides","text":""},{"location":"how-to-guides/#aws-profile-configuration","title":"AWS Profile Configuration","text":"<ul> <li>Install AWS CLI - Command line tool.</li> <li>Create an AWS AMI user then extract Access ID &amp; key.</li> <li>Configure AWS CLI profile by:</li> </ul> <pre><code>aws configure --profile [PROFILE_NAME]  # Replace [PROFILE_NAME] with your profile name\n# 2- Input the Access ID &amp; Key as required.\n# 3- Specify the defalut region.\n</code></pre>"},{"location":"how-to-guides/#check-installed-python-version","title":"Check installed Python version","text":"<ul> <li>Ensure you Python version is &gt;= 3.12.3 by:</li> </ul> <pre><code>python --version\n</code></pre>"},{"location":"how-to-guides/#install-eraxplor","title":"Install eraXplor","text":"<ul> <li>Install eraxplor too by:</li> </ul> <pre><code>pip install eraXplor\n</code></pre>"},{"location":"how-to-guides/#how-to-use","title":"How-To use","text":"<ul> <li>Simply run the <code>eraXplor</code> Command:</li> </ul> <pre><code>eraXplor\n# 1- input start date of data will be collected.\n# 2- input end date of date will be collected.\n# 3- input configure AWS profile name.\n# 4- [1] for Collecting &amp; sorting data based on AWS Accounts.\n#    [2] for Collecting &amp; sorting data based on AWS Services.\n# 5- input CSV file name, Default value = cost_export.csv\n</code></pre> <ul> <li>Check CSV file Created.</li> </ul>"},{"location":"how-to-guides/#how-to-schedule-regular-exports","title":"How-To Schedule Regular Exports","text":"<p>if you want automatic monthly exports; - use cron on linux/macOS or Task Scheduler on windows. - Example <code>cron</code> job monthly i.e. 1st day of the month at 2 AM.</p> <pre><code>0 2 1 * * /usr/bin/python3 /path/to/main.py --profile [PROFILE_NAME]\n</code></pre>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#main-application","title":"Main Application","text":"<p>eraXplor - AWS Cost Export Tool</p> <p>Main entry point with type-annotated workflow functions.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; python3 main.py\nEnter a start date value with YYYY-MM-DD format: 2025-1-1\nEnter a end date value with YYYY-MM-DD format: 2025-3-30\nEnter your AWS Profile name:\ndummy_profile\n</code></pre>"},{"location":"reference/#main.main","title":"<code>main()</code>","text":"<p>Orchestrates the cost export workflow with type hints.</p> Source code in <code>main.py</code> <pre><code>def main() -&gt; None:\n    \"\"\"Orchestrates the cost export workflow with type hints.\"\"\"\n    # Banner\n    banner, copyright = generate_banner()\n    print(f\"\\n\\n {termcolor.colored(banner, color=\"green\")}\")\n    print(f\"{termcolor.colored(copyright, color=\"green\")}\", end=\"\\n\\n\")\n\n    start_date_input = get_start_date_from_user()\n    end_date_input = get_end_date_from_user()\n    aws_profile_name_input = input(\"Enter your AWS Profile name: \")\n    fetch_monthly_account_cost_usage = monthly_account_cost_export(start_date_input, end_date_input, aws_profile_name_input)\n    # print(json.dumps(fetch_monthly_account_cost_usage, indent=4, default=str))  # print all\n    # print(fetch_monthly_account_cost_usage[0]['account_id'])  # print account id \n\n    csv_export(fetch_monthly_account_cost_usage)  # pass results to csv func\n</code></pre>"},{"location":"reference/#utilities","title":"Utilities","text":""},{"location":"reference/#banner-utilities","title":"Banner Utilities","text":""},{"location":"reference/#cost-export-utilities","title":"Cost Export Utilities","text":""},{"location":"reference/#utils.cost_export_utils.CostRecord","title":"<code>CostRecord</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Class type annotation tool dettermining the List Schema. Type definition for a single cost record.</p> Source code in <code>utils/cost_export_utils.py</code> <pre><code>class CostRecord(TypedDict):\n    \"\"\"Class type annotation tool dettermining the List Schema.\n    Type definition for a single cost record.\n    \"\"\"\n    time_period: Dict[str, str]  # {'Start': str, 'End': str}\n    account_id: str\n    account_cost: str\n</code></pre>"},{"location":"reference/#utils.cost_export_utils.monthly_account_cost_export","title":"<code>monthly_account_cost_export(start_date_input, end_date_input, aws_profile_name_input)</code>","text":"<p>Retrieves AWS account cost data for a specified time period using AWS Cost Explorer.</p> <p>Fetches the unblended costs for all linked accounts in an AWS organization for a given date range, grouped by account ID and returned in monthly granularity.</p> <p>Parameters:</p> Name Type Description Default <code>start_date_input</code> <code>str</code> <p>The start date of the cost report in YYYY-MM-DD format.</p> required <code>end_date_input</code> <code>str</code> <p>The end date of the cost report in YYYY-MM-DD format.</p> required <code>aws_profile_name_input</code> <code>str</code> <p>The name of the AWS profile to use for authentication, as configured in the local AWS credentials file.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>List[CostRecord]</code> <p>A list of dictionaries containing cost data, where each dictionary has: - time_period (dict): Contains 'Start' and 'End' dates for the time period - account_id (str): The AWS account ID - account_cost (str): The unblended cost amount as a string</p> <p>Raises:</p> Type Description <code>ClientError</code> <p>If there are AWS API authorization or parameter issues</p> <code>ProfileNotFound</code> <p>If the specified AWS profile doesn't exist</p> Example <p>This is an illustrative example that won't actually execute AWS calls:</p> <p>costs = monthly_account_cost_export('2023-01-01', '2023-01-31', 'dummy_profile')  # doctest: +SKIP [     {         'time_period': {'Start': '2023-01-01', 'End': '2023-01-31'},         'account_id': '123456789012',         'account_cost': '42.50'     } ]</p> <p>For actual testing, you would need to: 1. Have valid AWS credentials configured 2. Use a real profile name 3. Mark the test to run only when AWS available:</p> <p>monthly_account_cost_export('2023-01-01', '2023-01-31', 'real_profile')  # doctest: +SKIP</p> Source code in <code>utils/cost_export_utils.py</code> <pre><code>def monthly_account_cost_export(\n    start_date_input: Union[str, datetime],  # str | datetime \n    end_date_input: Union[str, datetime], \n    aws_profile_name_input: str\n    ) -&gt; List[CostRecord]:\n    \"\"\"Retrieves AWS account cost data for a specified time period using AWS Cost Explorer.\n\n    Fetches the unblended costs for all linked accounts in an AWS organization for a given\n    date range, grouped by account ID and returned in monthly granularity.\n\n    Args:\n        start_date_input (str): The start date of the cost report in YYYY-MM-DD format.\n        end_date_input (str): The end date of the cost report in YYYY-MM-DD format.\n        aws_profile_name_input (str): The name of the AWS profile to use for authentication,\n            as configured in the local AWS credentials file.\n\n    Returns:\n        list: A list of dictionaries containing cost data, where each dictionary has:\n            - time_period (dict): Contains 'Start' and 'End' dates for the time period\n            - account_id (str): The AWS account ID\n            - account_cost (str): The unblended cost amount as a string\n\n    Raises:\n        botocore.exceptions.ClientError: If there are AWS API authorization or parameter issues\n        botocore.exceptions.ProfileNotFound: If the specified AWS profile doesn't exist\n\n    Example:\n        This is an illustrative example that won't actually execute AWS calls:\n        &gt;&gt;&gt; costs = monthly_account_cost_export('2023-01-01', '2023-01-31', 'dummy_profile')  # doctest: +SKIP\n        [\n            {\n                'time_period': {'Start': '2023-01-01', 'End': '2023-01-31'},\n                'account_id': '123456789012',\n                'account_cost': '42.50'\n            }\n        ]\n\n        For actual testing, you would need to:\n        1. Have valid AWS credentials configured\n        2. Use a real profile name\n        3. Mark the test to run only when AWS available:\n        &gt;&gt;&gt; monthly_account_cost_export('2023-01-01', '2023-01-31', 'real_profile')  # doctest: +SKIP\n    \"\"\"\n    profile_session = boto3.Session(profile_name=str(aws_profile_name_input))\n    ce_client = profile_session.client('ce')\n\n    account_cost_usage = ce_client.get_cost_and_usage(\n        TimePeriod = {\n            'Start': str(start_date_input),\n            'End': str(end_date_input)\n        },\n        Granularity = 'MONTHLY',\n        Metrics = ['UnblendedCost'],\n        GroupBy = [  # group the result based on account ID\n            {\n                'Type': 'DIMENSION',\n                'Key': 'LINKED_ACCOUNT'\n            }\n        ]\n    )\n\n    # print(json.dumps(account_cost_usage, indent=4, default=str))\n    results = []\n    for item in account_cost_usage['ResultsByTime']:\n        time_period = item['TimePeriod']\n        for group in item['Groups']:\n            account_id = group['Keys'][0]\n            account_cost = group['Metrics']['UnblendedCost']['Amount']\n            results.append({\n                'time_period': time_period,\n                'account_id': account_id,\n                'account_cost': account_cost\n            })\n            # results.append(f\"Account ID: {termcolor.colored(account_id, color='yellow')}, Cost: {termcolor.colored(account_cost, color='yellow')}\")\n            # results.append(\"\\n\")\n    return results\n</code></pre>"},{"location":"reference/#csv-export-utilities","title":"CSV Export Utilities","text":""},{"location":"reference/#utils.csv_export_utils.csv_export","title":"<code>csv_export(fetch_monthly_account_cost_usage, filename='cost_repot.csv')</code>","text":"<p>Exports AWS cost data to a CSV file with standardized formatting.</p> <p>Takes the output from monthly_account_cost_export() and writes it to a CSV file with consistent column headers and proper formatting. The CSV will contain the time period, account IDs, and associated costs.</p> <p>Parameters:</p> Name Type Description Default <code>fetch_monthly_account_cost_usage</code> <code>list</code> <p>List of cost data dictionaries as returned by monthly_account_cost_export(). Each dictionary should contain: - time_period (dict): With 'Start' and 'End' keys - account_id (str): AWS account ID - account_cost (str): Cost amount as string</p> required <code>filename</code> <code>str</code> <p>Output filename for the CSV. Defaults to 'cost_report.csv'.</p> <code>'cost_repot.csv'</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Writes directly to file but doesn't return any value.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If input data is missing required fields</p> <code>IOError</code> <p>If there are issues writing to the specified file</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; test_data = [{\n...     'time_period': {'Start': '2023-01-01', 'End': '2023-01-31'},\n...     'account_id': '123456789012',\n...     'account_cost': '42.50'\n... }]\n&gt;&gt;&gt; csv_export(test_data, 'test_output.csv')\n\u2705 Data exported to test_output.csv\n</code></pre> <p>The file content would be: Start Date,End Date,Account ID,Cost 2023-01-01,2023-01-31,123456789012,42.50</p> Source code in <code>utils/csv_export_utils.py</code> <pre><code>def csv_export(\n    fetch_monthly_account_cost_usage: List[Dict[str, Any]], \n    filename: str ='cost_repot.csv'\n    ) -&gt; None:  # appending typehint\n# def csv_export(fetch_monthly_account_cost_usage: Union[List, Dict], filename: str ='cost_repot.csv') -&gt; None:  # appending type hint, accepting List with any value inside or single dict\n    \"\"\"Exports AWS cost data to a CSV file with standardized formatting.\n\n    Takes the output from monthly_account_cost_export() and writes it to a CSV file\n    with consistent column headers and proper formatting. The CSV will contain\n    the time period, account IDs, and associated costs.\n\n    Args:\n        fetch_monthly_account_cost_usage (list): List of cost data dictionaries as returned\n            by monthly_account_cost_export(). Each dictionary should contain:\n            - time_period (dict): With 'Start' and 'End' keys\n            - account_id (str): AWS account ID\n            - account_cost (str): Cost amount as string\n        filename (str, optional): Output filename for the CSV. Defaults to 'cost_report.csv'.\n\n    Returns:\n        None: Writes directly to file but doesn't return any value.\n\n    Raises:\n        KeyError: If input data is missing required fields\n        IOError: If there are issues writing to the specified file\n\n    Examples:\n        &gt;&gt;&gt; test_data = [{\n        ...     'time_period': {'Start': '2023-01-01', 'End': '2023-01-31'},\n        ...     'account_id': '123456789012',\n        ...     'account_cost': '42.50'\n        ... }]\n        &gt;&gt;&gt; csv_export(test_data, 'test_output.csv')  # doctest: +ELLIPSIS\n        \u2705 Data exported to test_output.csv\n\n        The file content would be:\n        Start Date,End Date,Account ID,Cost\n        2023-01-01,2023-01-31,123456789012,42.50\n    \"\"\"\n    # Define CSV headers (column names)\n    fieldnames = [\"Start Date\", \"End Date\", \"Account ID\", \"Cost\"]\n\n    # Create a CSV file with write mode\n    with open(filename, mode=\"w\", newline=\"\") as csvfile:\n\n        # Write headers\n        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)\n        writer.writeheader()\n\n        # Write each row of data\n        for result in fetch_monthly_account_cost_usage:\n            # print(f\"time_period': {result['time_period']}\")\n            # print(f\"account_id': {result['account_id']}\")\n            # print(f\"account_cost': {result['account_cost']}\") \n\n            writer.writerow({\n                \"Start Date\": result[\"time_period\"][\"Start\"],\n                \"End Date\": result[\"time_period\"][\"End\"],\n                \"Account ID\": result[\"account_id\"],\n                \"Cost\": result[\"account_cost\"]\n            })\n    print(f\"\u2705 Data exported to {filename}\")\n</code></pre>"},{"location":"reference/#date-utilities","title":"Date Utilities","text":""},{"location":"reference/#utils.date_utils.get_end_date_from_user","title":"<code>get_end_date_from_user()</code>","text":"<p>Prompts the user to enter an end date and validates the input format.</p> <p>Continuously prompts the user until a valid date is provided in the specified format or until the user interrupts with keyboard input. Handles both format validation and user interruption gracefully.</p> <p>Returns:</p> Type Description <p>datetime.date or None: Returns a date object if valid input is provided, returns None if the user interrupts the input (Ctrl+C).</p> <p>Raises:</p> Type Description <code>KeyboardInterrupt</code> <p>If the user interrupts the input prompt (though this is caught and handled within the function).</p> Example <p>date = get_end_date_from_user() Enter a start date value with YYYY-MM-DD format: 2023-05-15 print(date) 2023-05-15</p> <p>date = get_start_date_from_user() Enter an end date value with YYYY-MM-DD format: invalid Invalid date format, Please use YYYY-MM-DD Enter an end date value with YYYY-MM-DD format: ^C User interrupted. Exiting print(date) None</p> Source code in <code>utils/date_utils.py</code> <pre><code>def get_end_date_from_user():\n    \"\"\"Prompts the user to enter an end date and validates the input format.\n\n    Continuously prompts the user until a valid date is provided in the specified\n    format or until the user interrupts with keyboard input. Handles both format\n    validation and user interruption gracefully.\n\n    Returns:\n        datetime.date or None: Returns a date object if valid input is provided,\n            returns None if the user interrupts the input (Ctrl+C).\n\n    Raises:\n        KeyboardInterrupt: If the user interrupts the input prompt (though this is\n            caught and handled within the function).\n\n    Example:\n        &gt;&gt;&gt; date = get_end_date_from_user()\n        &gt;&gt;&gt; Enter a start date value with YYYY-MM-DD format: 2023-05-15\n        &gt;&gt;&gt; print(date)\n        2023-05-15\n\n        &gt;&gt;&gt; date = get_start_date_from_user()\n        &gt;&gt;&gt; Enter an end date value with YYYY-MM-DD format: invalid\n        &gt;&gt;&gt; Invalid date format, Please use YYYY-MM-DD\n        &gt;&gt;&gt; Enter an end date value with YYYY-MM-DD format: ^C\n        &gt;&gt;&gt; User interrupted. Exiting\n        &gt;&gt;&gt; print(date)\n        None\n    \"\"\"\n    while True:\n        try:\n            date_string = input(\"Enter an end date value with YYYY-MM-DD format: \")\n            date_object = datetime.strptime(date_string, \"%Y-%m-%d\").date()\n            return date_object\n        except ValueError:\n            print(\"Invalid date format, Please use YYYY-MM-DD\")\n        except KeyboardInterrupt:\n            print(\"\\nUser interrupted. Exiting\")\n            break\n    return None\n</code></pre>"},{"location":"reference/#utils.date_utils.get_start_date_from_user","title":"<code>get_start_date_from_user()</code>","text":"<p>Prompts the user to enter a start date and validates the input format.</p> <p>Continuously prompts the user until a valid date is provided in the specified format or until the user interrupts with keyboard input. Handles both format validation and user interruption gracefully.</p> <p>Returns:</p> Type Description <p>datetime.date or None: Returns a date object if valid input is provided, returns None if the user interrupts the input (Ctrl+C).</p> <p>Raises:</p> Type Description <code>KeyboardInterrupt</code> <p>If the user interrupts the input prompt (though this is caught and handled within the function).</p> Example <p>get_end_date_from_user()  # doctest: +SKIP Enter an end date value with YYYY-MM-DD format: 2023-05-15 2023-05-15</p> <p>get_end_date_from_user()  # doctest: +SKIP Enter an end date value with YYYY-MM-DD format: invalid Invalid date format, Please use YYYY-MM-DD Enter an end date value with YYYY-MM-DD format: ^C User interrupted. Exiting None</p> Source code in <code>utils/date_utils.py</code> <pre><code>def get_start_date_from_user():\n    \"\"\"Prompts the user to enter a start date and validates the input format.\n\n    Continuously prompts the user until a valid date is provided in the specified\n    format or until the user interrupts with keyboard input. Handles both format\n    validation and user interruption gracefully.\n\n    Returns:\n        datetime.date or None: Returns a date object if valid input is provided,\n            returns None if the user interrupts the input (Ctrl+C).\n\n    Raises:\n        KeyboardInterrupt: If the user interrupts the input prompt (though this is\n            caught and handled within the function).\n\n    Example:\n        &gt;&gt;&gt; get_end_date_from_user()  # doctest: +SKIP\n        Enter an end date value with YYYY-MM-DD format: 2023-05-15\n        2023-05-15\n\n        &gt;&gt;&gt; get_end_date_from_user()  # doctest: +SKIP\n        Enter an end date value with YYYY-MM-DD format: invalid\n        Invalid date format, Please use YYYY-MM-DD\n        Enter an end date value with YYYY-MM-DD format: ^C\n        User interrupted. Exiting\n        None\n    \"\"\"\n    while True:\n        try:\n            date_string = input(\"Enter a start date value with YYYY-MM-DD format: \")\n            date_object = datetime.strptime(date_string, \"%Y-%m-%d\").date()\n            return date_object\n        except ValueError:\n            print(\"Invalid date format, Please use YYYY-MM-DD\")\n        except KeyboardInterrupt:\n            print(\"\\nUser interrupted. Exiting\")\n            break\n\n    return None\n</code></pre>"},{"location":"tutorials/","title":"Tutorials","text":""},{"location":"tutorials/#1-setup-eraxplor-for-your-aws-account","title":"1. Setup eraXplor for your AWS Account","text":"<p>This tutorial walks you through setting up <code>eraXplor</code> to start exporting your AWS cost data automatically.</p>"},{"location":"tutorials/#prerequisites","title":"Prerequisites","text":"<ul> <li>AWS CLI</li> <li>Configure AWS Profile</li> <li> <p>Python version &gt;= 3.12.3</p> <p>Check that by:</p> </li> </ul> <pre><code>python3 --version\n</code></pre>"},{"location":"tutorials/#steps","title":"Steps","text":"<ol> <li>Install dependencies:</li> </ol> <pre><code>pip install -r requirements.txt\n</code></pre> <ol> <li>Configure AWS credentials:</li> </ol> <pre><code>aws configure --profile [PROFILE_NAME]\n</code></pre> <ol> <li>Run the tool:</li> </ol> <pre><code>python main.py\n</code></pre>"}]}